# -*- coding: utf-8 -*-
"""Lista1.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/github/Lipolly/reconhecimentoPadroes/blob/main/Lista1.ipynb

# Ricardo Piero Lippoli Batista | 202010505
#
"""

## Importando as Bibliotecas Necessárias ##
import warnings
warnings.filterwarnings("ignore")

import numpy as np
import pandas as pd
import seaborn as sns
import matplotlib.pyplot as plt
from sklearn.datasets import load_iris
from sklearn.model_selection import train_test_split
from sklearn.naive_bayes import GaussianNB
from copy import copy
from numpy.linalg import inv
sns.set()

#aplicando histogramas para os atributos contínuos:
def multigraficos_histograma(data, nrows, ncols, nomes):
    fig, axs = plt.subplots(nrows = nrows, ncols = ncols, figsize=(15, 5*nrows))
    k = 0
    for i in range(nrows):
        for j in range(ncols):
            sns.histplot(ax = axs[i,j], data = data, x = nomes[k])
            axs[i, j].set_xlabel(nomes[k])
            axs[i, j].set_ylabel("contagem")
            k+=1
        #
    #
#

nrows = 3
ncols = 5

from google.colab import drive
drive.mount('/content/drive')

# Lendo a base de dados
df = pd.read_excel("/content/drive/Shareddrives/Ufla/Lista1Reconhecimento/hcv_data.xlsx")
dfOrigin = copy(df)
df.head()

"""Nessa etapa, vamos codificar as variáveis que precisam de codificação e transformação em variáveis indicadoras

# 1_A) A Base de dados é referente a um banco de sangue. Nela podemos notar informações relevantes para definirmos qual o destino podemos alocar para cada amostra. De acordo com os atributos podemos montar um algoritmo de decisão para atribuirmos a melhor amostra de sangue para um paciente.
"""

df.shape

df.columns

"""# 1-B) Podemos notar que existem 615 amostras e 13 atributos

LIDANDO COM OS DADOS CATEGORICOS
"""

## Codificando dependentes - Transformação e variáveis indicadoras binárias
df = dfOrigin
k = np.where(df["Category"] == '0=Blood Donor')[0]
df["Category"][k] = 1
del k

k = np.where(df["Category"] == '0s=suspect Blood Donor')[0]
df['Category'][k] = 1
del k

k = np.where(df["Category"] =='1=Hepatitis')[0]
df['Category'][k] = -1
del k

k = np.where(df["Category"] == '2=Fibrosis')[0]
df['Category'][k] = 0
del k

k = np.where(df["Category"] == '3=Cirrhosis')[0]
df['Category'][k] = 0
del k

k = np.where(df["Category"] == '?')[0]
df.iloc[k] = np.nan
del k

## Codficando Area da propriedade - Transformação e variáveis indicadoras binárias

k = np.where(df["Age"] > 20)[0]
df["Age"][k] = 1
del k
##

#Codificando variáveis binárias para (0/1)
df["Sex"][df["Sex"] == 'm'] = 0
df["Sex"][df["Sex"] == 'f'] = 1

df.head()

df.isna().sum()

"""# 1-C) Sim, a base de dados possui tanto dados faltantes quanto NANs.

"""

multigraficos_histograma(df, nrows, ncols, var_num)

"""# 1_D) Sim Existe Desbalanceamento entre as classes. Isso fica evidente atravês dos gráficos gerados e entre a maior a maior proporção de dados de blood_donor e entre mais homens a mulheres dentre doadores.

# 1_E) Sim existem atributos assimetricos. Atributos assimetricos:
# Categoria, Sexo, BIL, ALT, PROT, CREA, GGT
"""

print("Variaveis com outliers: ")
df = dfOrigin

dsc = df[var_num].describe() #obtendo estatísticas descritivas dos atributos numericos

for name in dsc.columns:
    q1 = dsc[name]["25%"]
    q3 = dsc[name]["75%"]
    iqr = q3-q1

    min_ = q1 - 1.5*iqr
    max_ = q3 + 1.5*iqr

    out_inf = np.where(df[name] < min_)[0]
    out_sup = np.where(df[name] > max_)[0]

    if ((out_inf.shape[0] > 0) or (out_sup.shape[0] > 0)):
        print(name)
    #
#

print("\n A observação também poderá ser feita de forma visual, mediante os gráficos de boxplot")


fig, axs = plt.subplots(nrows = nrows, ncols = ncols, figsize=(15, 5*nrows))
sns.boxplot(ax = axs[0,0], data = df, x = 'Category', orient = 'h');  axs[0, 0].set_xlabel('Category')
sns.boxplot(ax = axs[0,1], data = df, x = 'Age', orient = 'h'); axs[0, 1].set_xlabel("Age")
sns.boxplot(ax = axs[0,2], data = df, x =  'Sex', orient = 'h'); axs[1, 0].set_xlabel( "Sex")
sns.boxplot(ax = axs[0,3], data = df, x = 'ALB', orient = 'h'); axs[1, 1].set_xlabel("ALB")
sns.boxplot(ax = axs[0,4], data = df, x =  'ALP', orient = 'h'); axs[1, 0].set_xlabel( "ALP")
sns.boxplot(ax = axs[1,0], data = df, x = "ALT", orient = 'h'); axs[1, 1].set_xlabel("ALT")
sns.boxplot(ax = axs[1,1], data = df, x =  "BIL", orient = 'h'); axs[1, 0].set_xlabel( "BIL")
sns.boxplot(ax = axs[1,2], data = df, x = "CHE", orient = 'h'); axs[1, 1].set_xlabel("CHE")
sns.boxplot(ax = axs[1,3], data = df, x = "CHOL", orient = 'h'); axs[1, 1].set_xlabel("CHOL")
sns.boxplot(ax = axs[1,4], data = df, x = "CREA", orient = 'h'); axs[1, 1].set_xlabel("CREA")
sns.boxplot(ax = axs[2,0], data = df, x = "GGT", orient = 'h'); axs[1, 1].set_xlabel("GGT")
sns.boxplot(ax = axs[2,1], data = df, x = "PROT", orient = 'h'); axs[1, 1].set_xlabel("PROT")

"""# 1-F)SIM EXISTEM ATRIBUTOS COM OUTLIERS
# Variaveis com outliers:
# Age, ALB, ALP, ALT, AST, BIL, CHE, CHOL, CREA, GGT, PROT

APENAS AUXILIARES
"""

df_tempvar = df
del df_tempvar["ID"]
var_num = df_tempvar.columns
del df_tempvar["Category"]
var_num2 = df_tempvar.columns
var_num2

"""# 1_G) IMPUTAÇÃO DA MÉDIA
# É tratado os dados faltantes e NANs de cada atributo faltante para posteriormente a efetuação da soma

"""

#Imputação da Média
df_temp = df.drop(603)
k = df_temp['ALB'].sum()/df_temp.shape[0]
df['ALB'][603] = k

df_temp = df
ALP = [541,545,546,568,569,570,571,576,581,582,583,584,585,590,592,603,613,614]
for i in ALP:
  df_temp = df.drop(i)

k = df_temp['ALP'].sum()/df_temp.shape[0]
for i in ALP:
  df['ALP'][i] = k


df_temp = df
df_temp = df.drop(540)
k = df_temp['ALT'].sum()/df_temp.shape[0]
df['ALT'][540] = k

df_temp = df
CHOL = [121,319,329,413,424,433,498,584,590,603]
for i in CHOL:
  df_temp = df.drop(i)

k = df_temp['CHOL'].sum()/df_temp.shape[0]
for i in CHOL:
  df['CHOL'][i] = k


df_temp = df
df_temp = df.drop(590)
k = df_temp['PROT'].sum()/df_temp.shape[0]
df['PROT'][590] = k

df_media = df
df_media.isnull().sum()

print(df)

"""# 1_G) IMPUTAÇÃO DA MEDIANA
# É tratado os dados faltantes e NANs de cada atributo faltante para posteriormente a efetuação do ordenamento

"""

#Imputação da Mediana
df = dfOrigin
df_temp = df.drop(603)
index_mediana = df_temp.shape[0]//2
df_temp2 = df_temp.sort_values(by=["ALB"], ignore_index=True)
k = df_temp2['ALB'][index_mediana]
df['ALB'][603] = k

df_temp = df
ALP = [541,545,546,568,569,570,571,576,581,582,583,584,585,590,592,603,613,614]
for i in ALP:
  df_temp = df.drop(i)

df_temp2 = df_temp.sort_values(by=["ALP"], ignore_index=True)
k = df_temp2['ALP'][index_mediana]

for i in ALP:
  df['ALP'][i] = k

df_temp = df.drop(540)
df_temp2 = df_temp.sort_values(by=["ALT"], ignore_index=True)
k = df_temp2['ALT'][index_mediana]
df['ALT'][540] = k

df_temp = df
CHOL = [121,319,329,413,424,433,498,584,590,603]
for i in CHOL:
  df_temp = df.drop(i)

df_temp2 = df_temp.sort_values(by=["CHOL"], ignore_index=True)
k = df_temp2['CHOL'][index_mediana]

for i in CHOL:
  df['CHOL'][i] = k

df_temp = df.drop(590)
df_temp2 = df_temp.sort_values(by=["PROT"], ignore_index=True)
k = df_temp2['PROT'][index_mediana]
df['PROT'][590] = k

df_mediana = df
df_mediana.isnull().sum()

"""# 1_G)IMPUTAÇÃO DO KNN"""

#Imputação do KNN
from sklearn.impute import KNNImputer
imputer = KNNImputer()
imputed_data = imputer.fit_transform(df)  # impute all the missing data
df_KNN= pd.DataFrame(imputed_data)
df_KNN.rename(columns = {0: "Id", 1: "Category", 2: "Age", 3: "Sex", 4: "ALB", 5: "ALP", 6: "ALT", 7: "AST", 8: "BIL" , 9: "CHE" , 10: "CHOL", 11: "CREA", 12: "GGT", 13: "PROT" }, inplace=True)
df_KNN

"""# 1_G) Na imputação da media calculamos uma média para cada elemento ao fazermos um somatorio de todos os elemntos na coluna e dividirmos pelos n elementos da coluna.
# Já na imputação da Mediana primeiro ordenamos os elementos em ordem crescente de termos na coluna e filtramos para pegar o elemento de posição n/2 da coluna onde n é o número de amostras na tabela.
# A imputação de KNN é feita por meio de algortimo já pronto da biblioteca sklearn onde ele imputa o valor médio dentre n vizinhos nos dados faltantes.

# 1_H) Para os atributos continuos da base de dados é recomendado a transformação logaritmica ou bloxplots dos dados continuos para a etapa de pós processamento e teste.

# Questão 2
"""

y0 = df_media.loc[df_media.ID[359]]
y1 = df_media.loc[df_media.ID[546]]
print(y1)

df_Q2 = df_media[(df_media['Category'] == "0=Blood Donor") | (df_media['Category'] == "1=Hepatitis")]
#df_Q2.shape
blood = df_Q2["Category"].value_counts("0=Blood Donor")
blood0 = blood[0]
blood1 = blood[1]
print(blood)
sex = df_Q2["Sex"].value_counts("m")
print("probabilidade Sexo: ",sex)
alp = df_Q2["ALP"].value_counts(34.6)
valoralp1 = alp[34.6]
valoralp0 = alp[56.2]
print("probabilidadeALP0: ",valoralp0)
print("probabilidadeALP1: ",valoralp1)
crea = df_Q2["CREA"].value_counts(81.2)
valorcrea1 = crea[81.2]
valorcrea0 = crea[69.0]
print("probabilidadeCREA0: ",valorcrea0)
print("probabilidadeCREA1: ",valorcrea1)
df_Q2f =  df_Q2[df_Q2['Category'] == "0=Blood Donor"]
PF = df_Q2f["Sex"].value_counts("f")
print("Probabilidade de ser doador e ser mulher: ",PF)
df_Q2M = df_Q2[df_Q2['Category'] == "1=Hepatitis"]
PM = df_Q2M["Sex"].value_counts("m")
print("Probabilidade de ter Hepatite e ser homem: ",PM)

from statistics import variance
dfcont = df_media[(df_media['Category'] == "0=Blood Donor")]
mean1 = dfcont['ALP'].sum()/dfcont.shape[0]
mean2 = dfcont['CREA'].sum()/dfcont.shape[0]
var_alp = variance(dfcont["ALP"],mean1)
var_crea = variance(dfcont["CREA"],mean2)
print("mediaALP: ",mean1)
print("mediaCREA: ",mean2)
print("varianciaALP: ",var_alp)
print("varianciaCREA: ",var_crea)
dfcont2 = df_media[(df_media['Category'] == "1=Hepatitis")]
meanH1 = dfcont2['ALP'].sum()/dfcont2.shape[0]
meanH2 = dfcont2['CREA'].sum()/dfcont2.shape[0]
var_alpH = variance(dfcont2["ALP"],meanH1)
var_creaH = variance(dfcont2["CREA"],meanH2)
print("mediaALP Hepatitis: ",meanH1)
print("mediaCREA Hepatitis: ",meanH2)
print("varianciaALP Hepatitis: ",var_alpH)
print("varianciaCREA Hepatitis: ",var_creaH)
probBDCont1 = (1*np.exp(-((56.2 - mean1)**2)/(2*var_alp))/(((2*np.pi)**(1/2))*var_alp))
print("Probabilidade de ser o ALP do 359 e blood donor: ", probBDCont1)
probBDCont2 = (1*np.exp(-((69.0 - mean2)**2)/(2*var_crea))/(((2*np.pi)**(1/2))*var_crea))
print("Probabilidade de ser o CREA do 359 e blood donor: ", probBDCont2)
probHepCont1 = (1*np.exp(-((56.2 - meanH1)**2)/(2*var_alpH))/(((2*np.pi)**(1/2))*var_alpH))
print("Probabilidade de ser o ALP do 359 e Hepatite: ", probHepCont1)
probHepCont2 = (1*np.exp(-((69.0 - meanH2)**2)/(2*var_creaH))/(((2*np.pi)**(1/2))*var_creaH))
print("Probabilidade de ser o CREA do 359 e hepatite: ", probHepCont2)


probBDCont3 = (1*np.exp(-((34.6 - mean1)**2)/(2*var_alp))/(((2*np.pi)**(1/2))*var_alp))
print("Probabilidade de ser o ALP do 546 e blood donor: ", probBDCont3)
probBDCont4 = (1*np.exp(-((81.2 - mean2)**2)/(2*var_crea))/(((2*np.pi)**(1/2))*var_crea))
print("Probabilidade de ser o CREA do 546 e blood donor: ", probBDCont4)
probHepCont3 = (1*np.exp(-((34.6 - meanH1)**2)/(2*var_alpH))/(((2*np.pi)**(1/2))*var_alpH))
print("Probabilidade de ser o ALP do 546 e Hepatite: ", probHepCont3)
probHepCont4 = (1*np.exp(-((81.2 - meanH2)**2)/(2*var_creaH))/(((2*np.pi)**(1/2))*var_creaH))
print("Probabilidade de ser o CREA do 546 e hepatite: ", probHepCont4)

"""# Questão 2: Por fim vamos determinar se classica corretamente

# RESPOSTA COMPLETA DA 2
Primeiramento usando a base de dados completa e sem igualar a quantidade de numeros de doadores de sangue e de hepatite a base de dados é enviessada e o bayesiano erraria + para classificações onde seria doador de sangue.

Porém, usando do descrito anteriormente:
Com os calculos de probabilidade feitos em python e com as probabilidades tais quais, probabilidade de ser mulher e doadora: 0.403377, homem e ter hepatite 0,8333 e as probabilidades continuas de ter ALP igual a 56.2 e ser doador, 0,00096 e de ter hepatite com ALP 56.2 igual a 0.000651, de ter CREA 69.0 e doador igual a 0.00149556 de ter CREA 69.0 e ter hepatite 0,000989 de ter ALP 34.6 e doador igual a 0,0002159, ALP 34.6 e hepatite 0,000657 como também, CREA 81.2 e ser doador igual 0,001872 e por fim CREA 81.2 com hepatite 0,000954

Após efetuados os calculos fizemos as multiplicações para verificação da probabilidade de acerto entre classe 0 e 1. Para tanto multiplicamos a probabilidade de ser mulher e doadora com o ALP igual a 56.2 e doador e multiplicamos ainda pela probabilidade de ter o CREA 69.0 e ser doador
com isso verificamos que a probabilidade é abaixo de 1 portanto ele acerta para essa classificação (valor: 5.79x10^-7) enquanto que para a probabilidade para hepatite com os valores de ALP e CREA o (valor: 1.07x10^-7) ele erra.
Feito para o segundo dado concluimos que ele acerta com uma probabilidade de: 5.23^-7 para ser homem e ter hepatite enquanto que erra para ser homem e doador ao ter valor de 2.41x10^-7
"""

PB359classe1 = (PF*probBDCont1*probBDCont2)#/blood[0]
print("Probabilidade de ser doador de sangue: ", PB359classe1)
PB359classe2 = (PM*probHepCont1*probHepCont2)#/blood[1]
print("Probabilidade de ter Hepatite: ", PB359classe2)
PB546classe1 = (PF*probBDCont3*probBDCont4)#/blood[0]
print("Probabilidade de ser doador de sangue: ", PB546classe1)
PB546classe2 = (PM*probHepCont3*probHepCont4)#/blood[1]
print("Probabilidade de ter Hepatite: ", PB546classe2)

"""# Sim os dados foram Classificados incocorretamente, visto que as probabilidades não convergem para a classificação. Onde para o ID359 o bayesiano não converge a indicar que é doadora de sangue e o ID546 a ser homem, ou seja, 0 e 1.

# QUESTÃO 3
"""

#Questão 3:
dfOrigin = df
values = ['0s=suspect Blood Donor', '2=Fibrosis', '3=Cirrhosis']
df_Exec3 = dfOrigin[df['Category'].isin(values) == False]

blood = df_Exec3[df_Exec3['Category'] == '0=Blood Donor'].iloc[:24]
hepatit = df_Exec3[df_Exec3['Category'] == '1=Hepatitis'].iloc[:24]

df_Exec3 = pd.concat([blood, hepatit])

#Questão 3:
df_Exec3['Category'] = df_Exec3['Category'].map({'0=Blood Donor': 1, '1=Hepatitis': -1})

df_Exec3['CHOL'] = np.log1p(df_Exec3['CHOL'])
df_Exec3['CHE'] = np.log1p(df_Exec3['CHE'])

X = df_Exec3[['CHOL', 'CHE']].values
y = df_Exec3['Category'].values

X = np.concatenate((X, np.ones((X.shape[0], 1))), axis=1)

w = np.dot(inv(np.dot(X.T, X)), np.dot(X.T, y))

w1, w2, w0 = w[0], w[1], w[2]

x_hyperplane = np.linspace(X[:, 0].min(), X[:, 0].max(), 1000)
y_hyperplane = (-w0 - w1 * x_hyperplane) / w2

plt.figure(figsize=(10, 6))
plt.scatter(X[y == 1][:, 0], X[y == 1][:, 1], label='Blood Donor', c='blue')
plt.scatter(X[y == -1][:, 0], X[y == -1][:, 1], label='Hepatitis', c='red')
plt.plot(x_hyperplane, y_hyperplane, color='green', label='Hiperplano de Separação')
plt.xlabel('CHOL')
plt.ylabel('CHE')
plt.legend()
plt.title('Gráfico de Dispersão com Classificador Linear e Reta de Separação')
plt.grid(True)
plt.show()

"""# **Questão 4:**

**Probabilidade priori**

P(C1) = 1000 / 2500 = 0.4

P(C2) = 1970 / 2500 = 0.788

P(C3) = 685 / 2500 = 0.274

P(C1^) = 1345 / 2500 = 0.538

P(C2^) = 1970 / 2500 = 0.788

P(C3^) = 685 / 2500 = 0.274


**Precisão e recall para cada classe:**

Classe C1:
Precisão (C1) = 900 / (900 + 105 + 340) = 0.717
Recall (C1) = 900 / (900 + 10 + 90) = 0.9

Classe C2:
Precisão (C2) = 1700 / (1700 + 10 + 260) = 0.856
Recall (C2) = 1700 / (1700 + 105 + 195) = 0.887

Classe C3:
Precisão (C3) = 400 / (400 + 90 + 195) = 0.571
Recall (C3) = 400 / (400 + 340 + 260) = 0.446

**Acurácia e kappa:**

Acurácia = (900 + 1700 + 400) / (2500) = 0.792
P_e = (0.4 * 0.538) + (0.788 * 0.788) + (0.274 * 0.274) = 0.514
Kappa = (0.792 - 0.514) / (1 - 0.514) = 0.554


*Com base nos valores calculados, o desempenho do modelo não é satisfatório, pois nenhum dos índices de avaliação está acima de 80%.*
"""